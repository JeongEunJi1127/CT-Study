## `Chapter 8` 다이나믹 프로그래밍

### :one: 다이나믹 프로그래밍
- `동적 계획법` 이라고도 표현
- 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법
- 다이나믹 프로그래밍의 조건
> 1. 큰 문제를 작은 문제로 나눌 수 있다 
> 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다
- 메모이제이션 기법
    - 다이나믹 프로그래밍을 구현하는 방법
    - 값을 저장하는 방법이므로 캐싱이라고도 함
    - 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 피보나치 수열
    - 일반적인 재귀함수 풀이의 시간복잡도 : O(2^N)
    - 다이나믹 프로그래밍(메모이제이션 기법)을 사용한 풀이의 시간복잡도 : O(N)
- 탑다운 방식
    - 하향식이라고도 함
    - `재귀 함수`를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법
    - 큰 문제를 해결하기 위해 작은 문제를 호출
    - 메모이제이션은 탑다운 방식에 국한되어 사용하는 표현
- 보텀업 방식
    - 상향식이라고도 함
    - `반복문`를 이용하여 작은 문제부터 차근차근 답을 도출하는 방법
    - 결과 저장용 리스트 `DP 테이블` 사용
    - 다이나믹 프로그래밍의 전형적인 형태

### :two: 1로 만들기
> 정수 x에 사용할 수 있는 연산은 다음 4가지이다
> 1. x가 5로 나누어 떨어지면 5로 나눈다
> 2. x가 3로 나누어 떨어지면 3으로 나눈다
> 3. x가 2로 나누어 떨어지면 2로 나눈다
> 4. x에서 1을 뺀다
>
>정수 x가 주어졌을 때 연산 4개를 적절히 사용하여 1을 만드는 연산횟수의 최솟값을 출력하시오

:speech_balloon: min(f(x-1),f(x/5),f(x/3),f(x/2)) + 1 을 구한다  
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%208%20%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1%EB%A1%9C%20%EB%A7%8C%EB%93%A4%EA%B8%B0.py)

### :three: 개미 전사
> 메뚜기 마을의 식량창고는 일직선으로 이어져있다. 개미 전사가 메뚜기 정찰병에게 들키지 않고 식량을 훔치려면 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하시오

:speech_balloon: i-1번째 식량창고와 i-2번째 식량창고 중 더 많은 식량을 털 수 있는 경우의 수를 구한다    
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%208%20%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9C%EB%AF%B8%20%EC%A0%84%EC%82%AC.py)

### :four: 바닥 공사
> 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 이 바닥을 1*2, 2*1, 2*2 덮개를 이용해 채우고자 한다. 이때 바닥을 채우는 모든 경우의 수를 구하시오

:speech_balloon: 타일링 문제 -> 다이나믹 프로그래밍 기초 예제. 왼쪽부터 바닥을 덮개로 채운다고 생각하면 두 가지 경우의 수가 나온다. 
1. 왼쪽부터 i-1까지 길이가 덮개로 이미 채워져 있으면 2*1 덮개를 채우는 하나의 경우의 수만 존재
2. 왼쪽부터 i-2까지 길이가 덮개로 이미 채워져 있으면 2*2 덮개, 1*2 덮개를 채우는 두개의 경우의 수 존재  

:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%208%20%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%B0%94%EB%8B%A5%20%EA%B3%B5%EC%82%AC.py)

### :five: 효율적인 화폐구성
> N가지 종류의 화폐가 있다. 화폐의 개수를 최소한으로 이용하여 그 가치의 합이 M원이 되도록 하려고 한다. 사용한 화폐의 구성은 같지만 순서가 다르면 같은 것으로 구분한다

:speech_balloon: 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾는다  
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%208%20%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%20%ED%99%94%ED%8F%90%20%EA%B5%AC%EC%84%B1.py)