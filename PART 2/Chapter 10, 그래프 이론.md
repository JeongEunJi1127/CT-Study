## `Chapter 10` 그래프 이론

### :one: 다양한 그래프 알고리즘
- 크루스칼 알고리즘 : 그리디 알고리즘
- 위상 정렬 알고리즘 : 큐, 스택 자료구조

#### 서로소 집합
- 서로소 : 공통 원소가 없는 두 집합
- 서로소 집합 자료구조 
    - 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
    - 트리 자료구조를 이용하여 집합 표현
    - union(합집합 연산) : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
    - find(찾기 연산) : 특정 원소가 속한 집합이 어떤 집합인지 알려주는 연산
    - 서로소 집합 자료구조의 시간복잡도 (V = 노드의 개수, M = find 연산 개수) : O(V+M)

    <br>

    - 서로소 집합 계산 알고리즘
    > 1. 합집합 연산을 확인하여 서로 연결된 두 노드 A, B를 확인  
    > 1-1. A와 B의 `루트노드` A', B'를 각각 찾는다  
    > 1-2. A'를 B'의 부모 노드로 설정 (B'가 A'를 가리킴 / A'가 B'보다 작은 값)
    > 2. 모든 합집합 연산을 처리할 때까지 1번 과정을 반복
    - 일반적인 find_parent 함수
    ```python
    def find_parent(parent,x):
        # 루트 노드가 아닐 경우 루트 노드를 찾을 때까지 재귀 호출
        if parent[x] != x:
            return find_parent(parent,parent[x])
        return x
    ```
    - 경로 압축 기법을 사용한 find_parent 함수
        - find 함수를 재귀적으로 호출한 뒤 부모 테이블 값을 갱신하는 기법
    ```python
    def find_parent(parent,x):
        if parent[x] != x:
            return find_parent(parent,parent[x])
        # 부모 테이블 값 갱신
        return parent[x]
    ```

    - 서로소 집합을 활용한 사이클 판별 알고리즘  
        - 방향성이 없는 무향 그래프에서만 적용 가능
        - 방향 그래프에서의 사이클 여부는 DFS 사용하여 판별
    > 1. 각 간선을 확인하여 두 노드의 루트 노드 확인  
    > 1-1. 루트노드가 서로 다르다면 두 노드에 대하여 합집합 연산 수행  
    > 1-2. 루트노드가 같다면 `사이클` 발생
    > 2. 모든 간선에 대하여 1번 과정을 반복

#### 신장 트리
- 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분의 그래프

#### 크루스칼 알고리즘
- `최소 신장 트리 알고리즘`의 대표적인 예시, 그리디 알고리즘
- 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시킨다.
- 간선의 개수 = 노드의 개수 - 1
- 가능한 한 최소한의 비용으로 신장 트리를 찾을 때 사용하는 알고리즘
- 크루스칼 알고리즘의 시간복잡도 (E = 간선의 개수) : O(ElogE)

> 1. 간선 데이터를 비용에 따라 오름차순 정렬
> 2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인   
> 2-1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함  
> 2-2. 사이클이 발생하면 최소 신장 트리에 포함 X
> 3. 모든 간선에 대하여 2번 과정을 반복

#### 위상 정렬 알고리즘
- 방향 그래프의 모든 노드를 `방향성에 거스르지 않도록 순서대로 나열하는 것`
- 정렬 알고리즘의 일종
- 순서가 정해져 있는 일련의 작업을 차례대로 수행할 때 사용
- 진입 차수 : 특정 노드로 들어오는 간선의 개수
- 모든 원소를 방문하기 전 큐가 빈다면 `사이클이 존재`
- 위상 정렬 알고리즘의 시간복잡도 (V = 노드의 개수,E = 간선의 개수) : O(V + E)
 
> 1. 진입차수가 0인 노드를 큐에 넣는다
> 2. 큐가 빌 때까지 다음의 과정을 반복  
> 2-1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거  
> 2-2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다

### :two: 팀 결성
> 학생들은 0번부터 N번까지의 번호를 부여받는다. 처음에는 모든 학생이 서로 다른 팀으로 구분되어 총 N+1개의 팀이 존재한다. M개의 연산을 수행할 수 있을 때 같은 팀 여부 확인 연산에 대한 연산 결과를 출력하는 프로그램을 작성하시오.
> 팀 합치기 연산 : 두 팀을 합치는 연산
> 같은 팀 여부 확인 연산 : 특정 두 학생이 같은 팀에 속하는지 확인하는 연산

:speech_balloon: 경로 압축 방식의 서로소 집합 자료구조 사용     
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%2010%2C%20%EA%B7%B8%EB%9E%98%ED%94%84%20%EC%9D%B4%EB%A1%A0/%ED%8C%80%20%EA%B2%B0%EC%84%B1.py)

### :three: 도시 분할 계획
> 마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 마을을 두개의 분리된 마을로 분할 하는 데 각 마을을 최소 신장 트리 구조로 만드려고 한다. 이를 구하는 프로그램을 작성하시오

:speech_balloon: 크루스칼 알고리즘으로 전체 그래프에 대한 최소 신장 트리 구한 뒤, 가장 큰 간선을 제거하면 된다.     
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%2010%2C%20%EA%B7%B8%EB%9E%98%ED%94%84%20%EC%9D%B4%EB%A1%A0/%EB%8F%84%EC%8B%9C%20%EB%B6%84%ED%95%A0%20%EA%B3%84%ED%9A%8D.py)

### :four: 커리큘럼
> 강의의 개수는 N개이며 모든 강의는 1번부터 N번까지의 번호를 가진다. 선수 강의가 있는 강의는 선수 강의를 들어야만 수강할 수 있다. 한번에 여러 개의 강의를 들을 수 있을 때 N개의 강의를 수강하기까지 걸리는 최소 시간을 각각 구하시오

:speech_balloon: 위상 정렬 알고리즘 사용      
:thought_balloon: [풀이](https://github.com/JeongEunJi1127/Algorithm/blob/master/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/Chapter%2010%2C%20%EA%B7%B8%EB%9E%98%ED%94%84%20%EC%9D%B4%EB%A1%A0/%EC%BB%A4%EB%A6%AC%ED%81%98%EB%9F%BC.py)